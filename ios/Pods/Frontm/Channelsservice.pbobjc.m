// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: channelsservice.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import "Channelsservice.pbobjc.h"
#import "Commonmessages.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - ChannelsserviceRoot

@implementation ChannelsserviceRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - ChannelsserviceRoot_FileDescriptor

static GPBFileDescriptor *ChannelsserviceRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"channels"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - SubUnsubInput

@implementation SubUnsubInput

@dynamic domainChannelsArray, domainChannelsArray_Count;

typedef struct SubUnsubInput__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *domainChannelsArray;
} SubUnsubInput__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "domainChannelsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(DomainChannels),
        .number = SubUnsubInput_FieldNumber_DomainChannelsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SubUnsubInput__storage_, domainChannelsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SubUnsubInput class]
                                     rootClass:[ChannelsserviceRoot class]
                                          file:ChannelsserviceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SubUnsubInput__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\000domainChannels\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DomainChannels

@implementation DomainChannels

@dynamic userDomain;
@dynamic channelsArray, channelsArray_Count;

typedef struct DomainChannels__storage_ {
  uint32_t _has_storage_[1];
  NSString *userDomain;
  NSMutableArray *channelsArray;
} DomainChannels__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userDomain",
        .dataTypeSpecific.className = NULL,
        .number = DomainChannels_FieldNumber_UserDomain,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DomainChannels__storage_, userDomain),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelsArray",
        .dataTypeSpecific.className = NULL,
        .number = DomainChannels_FieldNumber_ChannelsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DomainChannels__storage_, channelsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DomainChannels class]
                                     rootClass:[ChannelsserviceRoot class]
                                          file:ChannelsserviceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DomainChannels__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AddParticipantsInput

@implementation AddParticipantsInput

@dynamic channelName;
@dynamic userDomain;
@dynamic newUserIdsArray, newUserIdsArray_Count;

typedef struct AddParticipantsInput__storage_ {
  uint32_t _has_storage_[1];
  NSString *channelName;
  NSString *userDomain;
  NSMutableArray *newUserIdsArray;
} AddParticipantsInput__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "channelName",
        .dataTypeSpecific.className = NULL,
        .number = AddParticipantsInput_FieldNumber_ChannelName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AddParticipantsInput__storage_, channelName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userDomain",
        .dataTypeSpecific.className = NULL,
        .number = AddParticipantsInput_FieldNumber_UserDomain,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AddParticipantsInput__storage_, userDomain),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "newUserIdsArray",
        .dataTypeSpecific.className = NULL,
        .number = AddParticipantsInput_FieldNumber_NewUserIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AddParticipantsInput__storage_, newUserIdsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AddParticipantsInput class]
                                     rootClass:[ChannelsserviceRoot class]
                                          file:ChannelsserviceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AddParticipantsInput__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\013\000\002\n\000\003\000newUserIds\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CreateEditInput

@implementation CreateEditInput

@dynamic hasChannel, channel;

typedef struct CreateEditInput__storage_ {
  uint32_t _has_storage_[1];
  InputChannel *channel;
} CreateEditInput__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "channel",
        .dataTypeSpecific.className = GPBStringifySymbol(InputChannel),
        .number = CreateEditInput_FieldNumber_Channel,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CreateEditInput__storage_, channel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CreateEditInput class]
                                     rootClass:[ChannelsserviceRoot class]
                                          file:ChannelsserviceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CreateEditInput__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - InputChannel

@implementation InputChannel

@dynamic channelName;
@dynamic userDomain;
@dynamic description_p;
@dynamic channelType;
@dynamic discoverable;

typedef struct InputChannel__storage_ {
  uint32_t _has_storage_[1];
  NSString *channelName;
  NSString *userDomain;
  NSString *description_p;
  NSString *channelType;
  NSString *discoverable;
} InputChannel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "channelName",
        .dataTypeSpecific.className = NULL,
        .number = InputChannel_FieldNumber_ChannelName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(InputChannel__storage_, channelName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userDomain",
        .dataTypeSpecific.className = NULL,
        .number = InputChannel_FieldNumber_UserDomain,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(InputChannel__storage_, userDomain),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "description_p",
        .dataTypeSpecific.className = NULL,
        .number = InputChannel_FieldNumber_Description_p,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(InputChannel__storage_, description_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelType",
        .dataTypeSpecific.className = NULL,
        .number = InputChannel_FieldNumber_ChannelType,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(InputChannel__storage_, channelType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "discoverable",
        .dataTypeSpecific.className = NULL,
        .number = InputChannel_FieldNumber_Discoverable,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(InputChannel__storage_, discoverable),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[InputChannel class]
                                     rootClass:[ChannelsserviceRoot class]
                                          file:ChannelsserviceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InputChannel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\013\000\002\n\000\004\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChannelListResponse

@implementation ChannelListResponse

@dynamic error;
@dynamic contentArray, contentArray_Count;

typedef struct ChannelListResponse__storage_ {
  uint32_t _has_storage_[1];
  int32_t error;
  NSMutableArray *contentArray;
} ChannelListResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "error",
        .dataTypeSpecific.className = NULL,
        .number = ChannelListResponse_FieldNumber_Error,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChannelListResponse__storage_, error),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "contentArray",
        .dataTypeSpecific.className = GPBStringifySymbol(DBChannel),
        .number = ChannelListResponse_FieldNumber_ContentArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ChannelListResponse__storage_, contentArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChannelListResponse class]
                                     rootClass:[ChannelsserviceRoot class]
                                          file:ChannelsserviceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChannelListResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DBChannel

@implementation DBChannel

@dynamic channelId;
@dynamic channelType;
@dynamic createdOn;
@dynamic channelName;
@dynamic userDomain;
@dynamic hasChannelOwner, channelOwner;
@dynamic description_p;
@dynamic discoverable;
@dynamic logo;
@dynamic isPlatformChannel;
@dynamic participantsArray, participantsArray_Count;
@dynamic requestSent;
@dynamic isFavourite;

typedef struct DBChannel__storage_ {
  uint32_t _has_storage_[1];
  NSString *channelId;
  NSString *channelType;
  NSString *channelName;
  NSString *userDomain;
  ChannelOwner *channelOwner;
  NSString *description_p;
  NSString *discoverable;
  NSString *logo;
  NSMutableArray *participantsArray;
  double createdOn;
} DBChannel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "channelId",
        .dataTypeSpecific.className = NULL,
        .number = DBChannel_FieldNumber_ChannelId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DBChannel__storage_, channelId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelType",
        .dataTypeSpecific.className = NULL,
        .number = DBChannel_FieldNumber_ChannelType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DBChannel__storage_, channelType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "createdOn",
        .dataTypeSpecific.className = NULL,
        .number = DBChannel_FieldNumber_CreatedOn,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DBChannel__storage_, createdOn),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "channelName",
        .dataTypeSpecific.className = NULL,
        .number = DBChannel_FieldNumber_ChannelName,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DBChannel__storage_, channelName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userDomain",
        .dataTypeSpecific.className = NULL,
        .number = DBChannel_FieldNumber_UserDomain,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DBChannel__storage_, userDomain),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelOwner",
        .dataTypeSpecific.className = GPBStringifySymbol(ChannelOwner),
        .number = DBChannel_FieldNumber_ChannelOwner,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(DBChannel__storage_, channelOwner),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "description_p",
        .dataTypeSpecific.className = NULL,
        .number = DBChannel_FieldNumber_Description_p,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(DBChannel__storage_, description_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "discoverable",
        .dataTypeSpecific.className = NULL,
        .number = DBChannel_FieldNumber_Discoverable,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(DBChannel__storage_, discoverable),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "logo",
        .dataTypeSpecific.className = NULL,
        .number = DBChannel_FieldNumber_Logo,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(DBChannel__storage_, logo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isPlatformChannel",
        .dataTypeSpecific.className = NULL,
        .number = DBChannel_FieldNumber_IsPlatformChannel,
        .hasIndex = 9,
        .offset = 10,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "participantsArray",
        .dataTypeSpecific.className = NULL,
        .number = DBChannel_FieldNumber_ParticipantsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DBChannel__storage_, participantsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "requestSent",
        .dataTypeSpecific.className = NULL,
        .number = DBChannel_FieldNumber_RequestSent,
        .hasIndex = 11,
        .offset = 12,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "isFavourite",
        .dataTypeSpecific.className = NULL,
        .number = DBChannel_FieldNumber_IsFavourite,
        .hasIndex = 13,
        .offset = 14,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DBChannel class]
                                     rootClass:[ChannelsserviceRoot class]
                                          file:ChannelsserviceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DBChannel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\t\001\t\000\002\013\000\003\t\000\004\013\000\005\n\000\006\014\000\n\021\000\014\013\000\r\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChannelOwner

@implementation ChannelOwner

@dynamic emailAddress;
@dynamic userName;
@dynamic userId;

typedef struct ChannelOwner__storage_ {
  uint32_t _has_storage_[1];
  NSString *emailAddress;
  NSString *userName;
  NSString *userId;
} ChannelOwner__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "emailAddress",
        .dataTypeSpecific.className = NULL,
        .number = ChannelOwner_FieldNumber_EmailAddress,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChannelOwner__storage_, emailAddress),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userName",
        .dataTypeSpecific.className = NULL,
        .number = ChannelOwner_FieldNumber_UserName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChannelOwner__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = ChannelOwner_FieldNumber_UserId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ChannelOwner__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChannelOwner class]
                                     rootClass:[ChannelsserviceRoot class]
                                          file:ChannelsserviceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChannelOwner__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\014\000\002\010\000\003\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BooleanResponse

@implementation BooleanResponse

@dynamic error;
@dynamic contentArray, contentArray_Count;
@dynamic errorMessage;

typedef struct BooleanResponse__storage_ {
  uint32_t _has_storage_[1];
  int32_t error;
  GPBBoolArray *contentArray;
  NSString *errorMessage;
} BooleanResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "error",
        .dataTypeSpecific.className = NULL,
        .number = BooleanResponse_FieldNumber_Error,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BooleanResponse__storage_, error),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "contentArray",
        .dataTypeSpecific.className = NULL,
        .number = BooleanResponse_FieldNumber_ContentArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BooleanResponse__storage_, contentArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "errorMessage",
        .dataTypeSpecific.className = NULL,
        .number = BooleanResponse_FieldNumber_ErrorMessage,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BooleanResponse__storage_, errorMessage),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BooleanResponse class]
                                     rootClass:[ChannelsserviceRoot class]
                                          file:ChannelsserviceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BooleanResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\003\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CreateChannelResponse

@implementation CreateChannelResponse

@dynamic error;
@dynamic contentArray, contentArray_Count;
@dynamic errorMessage;

typedef struct CreateChannelResponse__storage_ {
  uint32_t _has_storage_[1];
  int32_t error;
  NSMutableArray *contentArray;
  NSString *errorMessage;
} CreateChannelResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "error",
        .dataTypeSpecific.className = NULL,
        .number = CreateChannelResponse_FieldNumber_Error,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CreateChannelResponse__storage_, error),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "contentArray",
        .dataTypeSpecific.className = NULL,
        .number = CreateChannelResponse_FieldNumber_ContentArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(CreateChannelResponse__storage_, contentArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "errorMessage",
        .dataTypeSpecific.className = NULL,
        .number = CreateChannelResponse_FieldNumber_ErrorMessage,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CreateChannelResponse__storage_, errorMessage),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CreateChannelResponse class]
                                     rootClass:[ChannelsserviceRoot class]
                                          file:ChannelsserviceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CreateChannelResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\003\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChannelDomainInput

@implementation ChannelDomainInput

@dynamic channelName;
@dynamic userDomain;

typedef struct ChannelDomainInput__storage_ {
  uint32_t _has_storage_[1];
  NSString *channelName;
  NSString *userDomain;
} ChannelDomainInput__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "channelName",
        .dataTypeSpecific.className = NULL,
        .number = ChannelDomainInput_FieldNumber_ChannelName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChannelDomainInput__storage_, channelName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userDomain",
        .dataTypeSpecific.className = NULL,
        .number = ChannelDomainInput_FieldNumber_UserDomain,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChannelDomainInput__storage_, userDomain),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChannelDomainInput class]
                                     rootClass:[ChannelsserviceRoot class]
                                          file:ChannelsserviceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChannelDomainInput__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\013\000\002\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ParticipantsListResponse

@implementation ParticipantsListResponse

@dynamic error;
@dynamic contentArray, contentArray_Count;

typedef struct ParticipantsListResponse__storage_ {
  uint32_t _has_storage_[1];
  int32_t error;
  NSMutableArray *contentArray;
} ParticipantsListResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "error",
        .dataTypeSpecific.className = NULL,
        .number = ParticipantsListResponse_FieldNumber_Error,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ParticipantsListResponse__storage_, error),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "contentArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ParticpantUser),
        .number = ParticipantsListResponse_FieldNumber_ContentArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ParticipantsListResponse__storage_, contentArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ParticipantsListResponse class]
                                     rootClass:[ChannelsserviceRoot class]
                                          file:ChannelsserviceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ParticipantsListResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ParticpantUser

@implementation ParticpantUser

@dynamic userName;
@dynamic userId;
@dynamic role;

typedef struct ParticpantUser__storage_ {
  uint32_t _has_storage_[1];
  NSString *userName;
  NSString *userId;
  NSString *role;
} ParticpantUser__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userName",
        .dataTypeSpecific.className = NULL,
        .number = ParticpantUser_FieldNumber_UserName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ParticpantUser__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = ParticpantUser_FieldNumber_UserId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ParticpantUser__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "role",
        .dataTypeSpecific.className = NULL,
        .number = ParticpantUser_FieldNumber_Role,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ParticpantUser__storage_, role),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ParticpantUser class]
                                     rootClass:[ChannelsserviceRoot class]
                                          file:ChannelsserviceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ParticpantUser__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\010\000\002\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateUsersInput

@implementation UpdateUsersInput

@dynamic channelName;
@dynamic userDomain;
@dynamic userIdsArray, userIdsArray_Count;

typedef struct UpdateUsersInput__storage_ {
  uint32_t _has_storage_[1];
  NSString *channelName;
  NSString *userDomain;
  NSMutableArray *userIdsArray;
} UpdateUsersInput__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "channelName",
        .dataTypeSpecific.className = NULL,
        .number = UpdateUsersInput_FieldNumber_ChannelName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateUsersInput__storage_, channelName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userDomain",
        .dataTypeSpecific.className = NULL,
        .number = UpdateUsersInput_FieldNumber_UserDomain,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UpdateUsersInput__storage_, userDomain),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userIdsArray",
        .dataTypeSpecific.className = NULL,
        .number = UpdateUsersInput_FieldNumber_UserIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(UpdateUsersInput__storage_, userIdsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateUsersInput class]
                                     rootClass:[ChannelsserviceRoot class]
                                          file:ChannelsserviceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateUsersInput__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\013\000\002\n\000\003\000userIds\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AuthorizeParticipantInput

@implementation AuthorizeParticipantInput

@dynamic channelName;
@dynamic userDomain;
@dynamic acceptedArray, acceptedArray_Count;
@dynamic ignoredArray, ignoredArray_Count;

typedef struct AuthorizeParticipantInput__storage_ {
  uint32_t _has_storage_[1];
  NSString *channelName;
  NSString *userDomain;
  NSMutableArray *acceptedArray;
  NSMutableArray *ignoredArray;
} AuthorizeParticipantInput__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "channelName",
        .dataTypeSpecific.className = NULL,
        .number = AuthorizeParticipantInput_FieldNumber_ChannelName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AuthorizeParticipantInput__storage_, channelName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userDomain",
        .dataTypeSpecific.className = NULL,
        .number = AuthorizeParticipantInput_FieldNumber_UserDomain,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AuthorizeParticipantInput__storage_, userDomain),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "acceptedArray",
        .dataTypeSpecific.className = NULL,
        .number = AuthorizeParticipantInput_FieldNumber_AcceptedArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AuthorizeParticipantInput__storage_, acceptedArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "ignoredArray",
        .dataTypeSpecific.className = NULL,
        .number = AuthorizeParticipantInput_FieldNumber_IgnoredArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AuthorizeParticipantInput__storage_, ignoredArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AuthorizeParticipantInput class]
                                     rootClass:[ChannelsserviceRoot class]
                                          file:ChannelsserviceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AuthorizeParticipantInput__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\013\000\002\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChangeOwnerInput

@implementation ChangeOwnerInput

@dynamic channelName;
@dynamic userDomain;
@dynamic newOwnerId;

typedef struct ChangeOwnerInput__storage_ {
  uint32_t _has_storage_[1];
  NSString *channelName;
  NSString *userDomain;
  NSString *newOwnerId;
} ChangeOwnerInput__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "channelName",
        .dataTypeSpecific.className = NULL,
        .number = ChangeOwnerInput_FieldNumber_ChannelName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChangeOwnerInput__storage_, channelName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userDomain",
        .dataTypeSpecific.className = NULL,
        .number = ChangeOwnerInput_FieldNumber_UserDomain,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChangeOwnerInput__storage_, userDomain),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "newOwnerId",
        .dataTypeSpecific.className = NULL,
        .number = ChangeOwnerInput_FieldNumber_NewOwnerId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ChangeOwnerInput__storage_, newOwnerId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChangeOwnerInput class]
                                     rootClass:[ChannelsserviceRoot class]
                                          file:ChannelsserviceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChangeOwnerInput__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\013\000\002\n\000\003\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
