// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: conversationservice.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import "Conversationservice.pbobjc.h"
#import "Commonmessages.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - ConversationserviceRoot

@implementation ConversationserviceRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - ConversationserviceRoot_FileDescriptor

static GPBFileDescriptor *ConversationserviceRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"conversation"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - UpdateFavouritesInput

@implementation UpdateFavouritesInput

@dynamic action;
@dynamic userDomain;
@dynamic conversationId;
@dynamic channelName;
@dynamic userId;
@dynamic botId;

typedef struct UpdateFavouritesInput__storage_ {
  uint32_t _has_storage_[1];
  NSString *action;
  NSString *userDomain;
  NSString *conversationId;
  NSString *channelName;
  NSString *userId;
  NSString *botId;
} UpdateFavouritesInput__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "action",
        .dataTypeSpecific.className = NULL,
        .number = UpdateFavouritesInput_FieldNumber_Action,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateFavouritesInput__storage_, action),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userDomain",
        .dataTypeSpecific.className = NULL,
        .number = UpdateFavouritesInput_FieldNumber_UserDomain,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UpdateFavouritesInput__storage_, userDomain),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "conversationId",
        .dataTypeSpecific.className = NULL,
        .number = UpdateFavouritesInput_FieldNumber_ConversationId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UpdateFavouritesInput__storage_, conversationId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelName",
        .dataTypeSpecific.className = NULL,
        .number = UpdateFavouritesInput_FieldNumber_ChannelName,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UpdateFavouritesInput__storage_, channelName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = UpdateFavouritesInput_FieldNumber_UserId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(UpdateFavouritesInput__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "botId",
        .dataTypeSpecific.className = NULL,
        .number = UpdateFavouritesInput_FieldNumber_BotId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(UpdateFavouritesInput__storage_, botId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateFavouritesInput class]
                                     rootClass:[ConversationserviceRoot class]
                                          file:ConversationserviceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateFavouritesInput__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\002\n\000\003\016\000\004\013\000\005\006\000\006\005\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateFavouritesResponse

@implementation UpdateFavouritesResponse

@dynamic error;

typedef struct UpdateFavouritesResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *error;
} UpdateFavouritesResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "error",
        .dataTypeSpecific.className = NULL,
        .number = UpdateFavouritesResponse_FieldNumber_Error,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateFavouritesResponse__storage_, error),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateFavouritesResponse class]
                                     rootClass:[ConversationserviceRoot class]
                                          file:ConversationserviceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateFavouritesResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TimelineResponse

@implementation TimelineResponse

@dynamic error;
@dynamic hasContent, content;

typedef struct TimelineResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *error;
  TimelineContent *content;
} TimelineResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "error",
        .dataTypeSpecific.className = NULL,
        .number = TimelineResponse_FieldNumber_Error,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TimelineResponse__storage_, error),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "content",
        .dataTypeSpecific.className = GPBStringifySymbol(TimelineContent),
        .number = TimelineResponse_FieldNumber_Content,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TimelineResponse__storage_, content),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TimelineResponse class]
                                     rootClass:[ConversationserviceRoot class]
                                          file:ConversationserviceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TimelineResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TimelineContent

@implementation TimelineContent

@dynamic conversationsArray, conversationsArray_Count;
@dynamic favouritesArray, favouritesArray_Count;

typedef struct TimelineContent__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *conversationsArray;
  NSMutableArray *favouritesArray;
} TimelineContent__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "conversationsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(TimelineConversation),
        .number = TimelineContent_FieldNumber_ConversationsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TimelineContent__storage_, conversationsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "favouritesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(TimelineConversation),
        .number = TimelineContent_FieldNumber_FavouritesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TimelineContent__storage_, favouritesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TimelineContent class]
                                     rootClass:[ConversationserviceRoot class]
                                          file:ConversationserviceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TimelineContent__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TimelineConversation

@implementation TimelineConversation

@dynamic closed;
@dynamic participantsArray, participantsArray_Count;
@dynamic createdOn;
@dynamic modifiedOn;
@dynamic userDomain;
@dynamic conversationId;
@dynamic createdBy;
@dynamic onChannelsArray, onChannelsArray_Count;
@dynamic hasBot, bot;
@dynamic lastMessage;
@dynamic hasContact, contact;

typedef struct TimelineConversation__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *participantsArray;
  NSString *userDomain;
  NSString *conversationId;
  NSString *createdBy;
  NSMutableArray *onChannelsArray;
  TimelineBotInfo *bot;
  NSData *lastMessage;
  TimelineContact *contact;
  double createdOn;
  double modifiedOn;
} TimelineConversation__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "closed",
        .dataTypeSpecific.className = NULL,
        .number = TimelineConversation_FieldNumber_Closed,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "participantsArray",
        .dataTypeSpecific.className = NULL,
        .number = TimelineConversation_FieldNumber_ParticipantsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TimelineConversation__storage_, participantsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "createdOn",
        .dataTypeSpecific.className = NULL,
        .number = TimelineConversation_FieldNumber_CreatedOn,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TimelineConversation__storage_, createdOn),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "modifiedOn",
        .dataTypeSpecific.className = NULL,
        .number = TimelineConversation_FieldNumber_ModifiedOn,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(TimelineConversation__storage_, modifiedOn),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "userDomain",
        .dataTypeSpecific.className = NULL,
        .number = TimelineConversation_FieldNumber_UserDomain,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(TimelineConversation__storage_, userDomain),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "conversationId",
        .dataTypeSpecific.className = NULL,
        .number = TimelineConversation_FieldNumber_ConversationId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(TimelineConversation__storage_, conversationId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "createdBy",
        .dataTypeSpecific.className = NULL,
        .number = TimelineConversation_FieldNumber_CreatedBy,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(TimelineConversation__storage_, createdBy),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "onChannelsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(TimelineChannels),
        .number = TimelineConversation_FieldNumber_OnChannelsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TimelineConversation__storage_, onChannelsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "bot",
        .dataTypeSpecific.className = GPBStringifySymbol(TimelineBotInfo),
        .number = TimelineConversation_FieldNumber_Bot,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(TimelineConversation__storage_, bot),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "lastMessage",
        .dataTypeSpecific.className = NULL,
        .number = TimelineConversation_FieldNumber_LastMessage,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(TimelineConversation__storage_, lastMessage),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "contact",
        .dataTypeSpecific.className = GPBStringifySymbol(TimelineContact),
        .number = TimelineConversation_FieldNumber_Contact,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(TimelineConversation__storage_, contact),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TimelineConversation class]
                                     rootClass:[ConversationserviceRoot class]
                                          file:ConversationserviceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TimelineConversation__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\007\003\t\000\004\n\000\005\n\000\006\016\000\007\t\000\010\000onChannels\000\n\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TimelineChannels

@implementation TimelineChannels

@dynamic channelName;
@dynamic userDomain;

typedef struct TimelineChannels__storage_ {
  uint32_t _has_storage_[1];
  NSString *channelName;
  NSString *userDomain;
} TimelineChannels__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "channelName",
        .dataTypeSpecific.className = NULL,
        .number = TimelineChannels_FieldNumber_ChannelName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TimelineChannels__storage_, channelName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userDomain",
        .dataTypeSpecific.className = NULL,
        .number = TimelineChannels_FieldNumber_UserDomain,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TimelineChannels__storage_, userDomain),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TimelineChannels class]
                                     rootClass:[ConversationserviceRoot class]
                                          file:ConversationserviceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TimelineChannels__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\013\000\002\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TimelineBotInfo

@implementation TimelineBotInfo

@dynamic allowResetConversation;
@dynamic botName;
@dynamic logoURL;
@dynamic slug;
@dynamic userDomain;
@dynamic botURL;
@dynamic description_p;
@dynamic botId;
@dynamic systemBot;

typedef struct TimelineBotInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *allowResetConversation;
  NSString *botName;
  NSString *logoURL;
  NSString *slug;
  NSString *userDomain;
  NSString *botURL;
  NSString *description_p;
  NSString *botId;
} TimelineBotInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "allowResetConversation",
        .dataTypeSpecific.className = NULL,
        .number = TimelineBotInfo_FieldNumber_AllowResetConversation,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TimelineBotInfo__storage_, allowResetConversation),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "botName",
        .dataTypeSpecific.className = NULL,
        .number = TimelineBotInfo_FieldNumber_BotName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TimelineBotInfo__storage_, botName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "logoURL",
        .dataTypeSpecific.className = NULL,
        .number = TimelineBotInfo_FieldNumber_LogoURL,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TimelineBotInfo__storage_, logoURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "slug",
        .dataTypeSpecific.className = NULL,
        .number = TimelineBotInfo_FieldNumber_Slug,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(TimelineBotInfo__storage_, slug),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userDomain",
        .dataTypeSpecific.className = NULL,
        .number = TimelineBotInfo_FieldNumber_UserDomain,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(TimelineBotInfo__storage_, userDomain),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "botURL",
        .dataTypeSpecific.className = NULL,
        .number = TimelineBotInfo_FieldNumber_BotURL,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(TimelineBotInfo__storage_, botURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "description_p",
        .dataTypeSpecific.className = NULL,
        .number = TimelineBotInfo_FieldNumber_Description_p,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(TimelineBotInfo__storage_, description_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "botId",
        .dataTypeSpecific.className = NULL,
        .number = TimelineBotInfo_FieldNumber_BotId,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(TimelineBotInfo__storage_, botId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "systemBot",
        .dataTypeSpecific.className = NULL,
        .number = TimelineBotInfo_FieldNumber_SystemBot,
        .hasIndex = 8,
        .offset = 9,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TimelineBotInfo class]
                                     rootClass:[ConversationserviceRoot class]
                                          file:ConversationserviceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TimelineBotInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\007\001\026\000\002\007\000\003\005!!\000\005\n\000\006\004!!\000\010\005\000\t\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TimelineContact

@implementation TimelineContact

@dynamic visible;
@dynamic searchable;
@dynamic userName;
@dynamic userId;

typedef struct TimelineContact__storage_ {
  uint32_t _has_storage_[1];
  NSString *userName;
  NSString *userId;
} TimelineContact__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "visible",
        .dataTypeSpecific.className = NULL,
        .number = TimelineContact_FieldNumber_Visible,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "searchable",
        .dataTypeSpecific.className = NULL,
        .number = TimelineContact_FieldNumber_Searchable,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "userName",
        .dataTypeSpecific.className = NULL,
        .number = TimelineContact_FieldNumber_UserName,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(TimelineContact__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = TimelineContact_FieldNumber_UserId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(TimelineContact__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TimelineContact class]
                                     rootClass:[ConversationserviceRoot class]
                                          file:ConversationserviceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TimelineContact__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\003\010\000\004\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CatalogResponse

@implementation CatalogResponse

@dynamic botsArray, botsArray_Count;

typedef struct CatalogResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *botsArray;
} CatalogResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "botsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(CatalogBot),
        .number = CatalogResponse_FieldNumber_BotsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(CatalogResponse__storage_, botsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CatalogResponse class]
                                     rootClass:[ConversationserviceRoot class]
                                          file:ConversationserviceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CatalogResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CatalogBot

@implementation CatalogBot

@dynamic botId;
@dynamic userDomain;
@dynamic allowResetConversation;
@dynamic hasBotClients, botClients;
@dynamic botName;
@dynamic botNameSearch;
@dynamic botURL;
@dynamic categoryArray, categoryArray_Count;
@dynamic hasDependencies, dependencies;
@dynamic description_p;
@dynamic descriptionSearch;
@dynamic logoURL;
@dynamic slug;
@dynamic userRolesArray, userRolesArray_Count;
@dynamic version;
@dynamic developer;
@dynamic featured;
@dynamic systemBot;
@dynamic minRequiredPlatformVersion;

typedef struct CatalogBot__storage_ {
  uint32_t _has_storage_[1];
  NSString *botId;
  NSString *userDomain;
  NSString *allowResetConversation;
  CatalogBotClients *botClients;
  NSString *botName;
  NSString *botNameSearch;
  NSString *botURL;
  NSMutableArray *categoryArray;
  CatalogDependencies *dependencies;
  NSString *description_p;
  NSString *descriptionSearch;
  NSString *logoURL;
  NSString *slug;
  NSMutableArray *userRolesArray;
  NSString *version;
  NSString *developer;
  NSString *minRequiredPlatformVersion;
} CatalogBot__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "botId",
        .dataTypeSpecific.className = NULL,
        .number = CatalogBot_FieldNumber_BotId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CatalogBot__storage_, botId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userDomain",
        .dataTypeSpecific.className = NULL,
        .number = CatalogBot_FieldNumber_UserDomain,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CatalogBot__storage_, userDomain),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "allowResetConversation",
        .dataTypeSpecific.className = NULL,
        .number = CatalogBot_FieldNumber_AllowResetConversation,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CatalogBot__storage_, allowResetConversation),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "botClients",
        .dataTypeSpecific.className = GPBStringifySymbol(CatalogBotClients),
        .number = CatalogBot_FieldNumber_BotClients,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(CatalogBot__storage_, botClients),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "botName",
        .dataTypeSpecific.className = NULL,
        .number = CatalogBot_FieldNumber_BotName,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(CatalogBot__storage_, botName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "botNameSearch",
        .dataTypeSpecific.className = NULL,
        .number = CatalogBot_FieldNumber_BotNameSearch,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(CatalogBot__storage_, botNameSearch),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "botURL",
        .dataTypeSpecific.className = NULL,
        .number = CatalogBot_FieldNumber_BotURL,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(CatalogBot__storage_, botURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "categoryArray",
        .dataTypeSpecific.className = NULL,
        .number = CatalogBot_FieldNumber_CategoryArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(CatalogBot__storage_, categoryArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "dependencies",
        .dataTypeSpecific.className = GPBStringifySymbol(CatalogDependencies),
        .number = CatalogBot_FieldNumber_Dependencies,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(CatalogBot__storage_, dependencies),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "description_p",
        .dataTypeSpecific.className = NULL,
        .number = CatalogBot_FieldNumber_Description_p,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(CatalogBot__storage_, description_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "descriptionSearch",
        .dataTypeSpecific.className = NULL,
        .number = CatalogBot_FieldNumber_DescriptionSearch,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(CatalogBot__storage_, descriptionSearch),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "logoURL",
        .dataTypeSpecific.className = NULL,
        .number = CatalogBot_FieldNumber_LogoURL,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(CatalogBot__storage_, logoURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "slug",
        .dataTypeSpecific.className = NULL,
        .number = CatalogBot_FieldNumber_Slug,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(CatalogBot__storage_, slug),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userRolesArray",
        .dataTypeSpecific.className = NULL,
        .number = CatalogBot_FieldNumber_UserRolesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(CatalogBot__storage_, userRolesArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "version",
        .dataTypeSpecific.className = NULL,
        .number = CatalogBot_FieldNumber_Version,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(CatalogBot__storage_, version),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "developer",
        .dataTypeSpecific.className = NULL,
        .number = CatalogBot_FieldNumber_Developer,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(CatalogBot__storage_, developer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "featured",
        .dataTypeSpecific.className = NULL,
        .number = CatalogBot_FieldNumber_Featured,
        .hasIndex = 14,
        .offset = 15,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "systemBot",
        .dataTypeSpecific.className = NULL,
        .number = CatalogBot_FieldNumber_SystemBot,
        .hasIndex = 16,
        .offset = 17,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "minRequiredPlatformVersion",
        .dataTypeSpecific.className = NULL,
        .number = CatalogBot_FieldNumber_MinRequiredPlatformVersion,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(CatalogBot__storage_, minRequiredPlatformVersion),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CatalogBot class]
                                     rootClass:[ConversationserviceRoot class]
                                          file:ConversationserviceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CatalogBot__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\014\001\005\000\002\n\000\003\026\000\004\n\000\005\007\000\006\r\000\007\004!!\000\013\021\000\014\005!!\000\016\000userRo"
        "les\000\022\t\000\023\032\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CatalogBotClients

@implementation CatalogBotClients

@dynamic mobile;
@dynamic web;

typedef struct CatalogBotClients__storage_ {
  uint32_t _has_storage_[1];
} CatalogBotClients__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "mobile",
        .dataTypeSpecific.className = NULL,
        .number = CatalogBotClients_FieldNumber_Mobile,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "web",
        .dataTypeSpecific.className = NULL,
        .number = CatalogBotClients_FieldNumber_Web,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CatalogBotClients class]
                                     rootClass:[ConversationserviceRoot class]
                                          file:ConversationserviceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CatalogBotClients__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CatalogDependencies

@implementation CatalogDependencies

@dynamic hasAgentGuardService, agentGuardService;
@dynamic hasAuthContext, authContext;
@dynamic hasArchiveUtils, archiveUtils;
@dynamic hasBotUtils, botUtils;
@dynamic hasAutoRenewConversationContext, autoRenewConversationContext;

typedef struct CatalogDependencies__storage_ {
  uint32_t _has_storage_[1];
  CatalogDependency *agentGuardService;
  CatalogDependency *authContext;
  CatalogDependency *archiveUtils;
  CatalogDependency *botUtils;
  CatalogDependency *autoRenewConversationContext;
} CatalogDependencies__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "agentGuardService",
        .dataTypeSpecific.className = GPBStringifySymbol(CatalogDependency),
        .number = CatalogDependencies_FieldNumber_AgentGuardService,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CatalogDependencies__storage_, agentGuardService),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "authContext",
        .dataTypeSpecific.className = GPBStringifySymbol(CatalogDependency),
        .number = CatalogDependencies_FieldNumber_AuthContext,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CatalogDependencies__storage_, authContext),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "archiveUtils",
        .dataTypeSpecific.className = GPBStringifySymbol(CatalogDependency),
        .number = CatalogDependencies_FieldNumber_ArchiveUtils,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CatalogDependencies__storage_, archiveUtils),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "botUtils",
        .dataTypeSpecific.className = GPBStringifySymbol(CatalogDependency),
        .number = CatalogDependencies_FieldNumber_BotUtils,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(CatalogDependencies__storage_, botUtils),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "autoRenewConversationContext",
        .dataTypeSpecific.className = GPBStringifySymbol(CatalogDependency),
        .number = CatalogDependencies_FieldNumber_AutoRenewConversationContext,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(CatalogDependencies__storage_, autoRenewConversationContext),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CatalogDependencies class]
                                     rootClass:[ConversationserviceRoot class]
                                          file:ConversationserviceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CatalogDependencies__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\001\021\000\002\013\000\003\014\000\004\010\000\005\034\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CatalogDependency

@implementation CatalogDependency

@dynamic remote;
@dynamic version;
@dynamic URL;

typedef struct CatalogDependency__storage_ {
  uint32_t _has_storage_[1];
  NSString *version;
  NSString *URL;
} CatalogDependency__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "remote",
        .dataTypeSpecific.className = NULL,
        .number = CatalogDependency_FieldNumber_Remote,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "version",
        .dataTypeSpecific.className = NULL,
        .number = CatalogDependency_FieldNumber_Version,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CatalogDependency__storage_, version),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = CatalogDependency_FieldNumber_URL,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(CatalogDependency__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CatalogDependency class]
                                     rootClass:[ConversationserviceRoot class]
                                          file:ConversationserviceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CatalogDependency__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\003!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetConversationDetailsInput

@implementation GetConversationDetailsInput

@dynamic conversationId;
@dynamic botId;
@dynamic createdBy;

typedef struct GetConversationDetailsInput__storage_ {
  uint32_t _has_storage_[1];
  NSString *conversationId;
  NSString *botId;
  NSString *createdBy;
} GetConversationDetailsInput__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "conversationId",
        .dataTypeSpecific.className = NULL,
        .number = GetConversationDetailsInput_FieldNumber_ConversationId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetConversationDetailsInput__storage_, conversationId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "botId",
        .dataTypeSpecific.className = NULL,
        .number = GetConversationDetailsInput_FieldNumber_BotId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetConversationDetailsInput__storage_, botId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "createdBy",
        .dataTypeSpecific.className = NULL,
        .number = GetConversationDetailsInput_FieldNumber_CreatedBy,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetConversationDetailsInput__storage_, createdBy),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetConversationDetailsInput class]
                                     rootClass:[ConversationserviceRoot class]
                                          file:ConversationserviceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetConversationDetailsInput__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\016\000\002\005\000\003\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetConversationDetailsResponse

@implementation GetConversationDetailsResponse

@dynamic onChannelsArray, onChannelsArray_Count;
@dynamic hasConversationOwner, conversationOwner;
@dynamic participantsArray, participantsArray_Count;
@dynamic error;

typedef struct GetConversationDetailsResponse__storage_ {
  uint32_t _has_storage_[1];
  int32_t error;
  NSMutableArray *onChannelsArray;
  GetConversationDetailsUser *conversationOwner;
  NSMutableArray *participantsArray;
} GetConversationDetailsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "onChannelsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GetConversationDetailsChannels),
        .number = GetConversationDetailsResponse_FieldNumber_OnChannelsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetConversationDetailsResponse__storage_, onChannelsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "conversationOwner",
        .dataTypeSpecific.className = GPBStringifySymbol(GetConversationDetailsUser),
        .number = GetConversationDetailsResponse_FieldNumber_ConversationOwner,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetConversationDetailsResponse__storage_, conversationOwner),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "participantsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GetConversationDetailsUser),
        .number = GetConversationDetailsResponse_FieldNumber_ParticipantsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetConversationDetailsResponse__storage_, participantsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "error",
        .dataTypeSpecific.className = NULL,
        .number = GetConversationDetailsResponse_FieldNumber_Error,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetConversationDetailsResponse__storage_, error),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetConversationDetailsResponse class]
                                     rootClass:[ConversationserviceRoot class]
                                          file:ConversationserviceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetConversationDetailsResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\000onChannels\000\002\021\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetConversationDetailsUser

@implementation GetConversationDetailsUser

@dynamic userId;
@dynamic userName;

typedef struct GetConversationDetailsUser__storage_ {
  uint32_t _has_storage_[1];
  NSString *userId;
  NSString *userName;
} GetConversationDetailsUser__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = GetConversationDetailsUser_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetConversationDetailsUser__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userName",
        .dataTypeSpecific.className = NULL,
        .number = GetConversationDetailsUser_FieldNumber_UserName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetConversationDetailsUser__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetConversationDetailsUser class]
                                     rootClass:[ConversationserviceRoot class]
                                          file:ConversationserviceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetConversationDetailsUser__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\006\000\002\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetConversationDetailsChannels

@implementation GetConversationDetailsChannels

@dynamic channelName;
@dynamic userDomain;
@dynamic channelId;
@dynamic description_p;
@dynamic logo;

typedef struct GetConversationDetailsChannels__storage_ {
  uint32_t _has_storage_[1];
  NSString *channelName;
  NSString *userDomain;
  NSString *channelId;
  NSString *description_p;
  NSString *logo;
} GetConversationDetailsChannels__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "channelName",
        .dataTypeSpecific.className = NULL,
        .number = GetConversationDetailsChannels_FieldNumber_ChannelName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetConversationDetailsChannels__storage_, channelName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userDomain",
        .dataTypeSpecific.className = NULL,
        .number = GetConversationDetailsChannels_FieldNumber_UserDomain,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetConversationDetailsChannels__storage_, userDomain),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelId",
        .dataTypeSpecific.className = NULL,
        .number = GetConversationDetailsChannels_FieldNumber_ChannelId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetConversationDetailsChannels__storage_, channelId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "description_p",
        .dataTypeSpecific.className = NULL,
        .number = GetConversationDetailsChannels_FieldNumber_Description_p,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GetConversationDetailsChannels__storage_, description_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "logo",
        .dataTypeSpecific.className = NULL,
        .number = GetConversationDetailsChannels_FieldNumber_Logo,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GetConversationDetailsChannels__storage_, logo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetConversationDetailsChannels class]
                                     rootClass:[ConversationserviceRoot class]
                                          file:ConversationserviceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetConversationDetailsChannels__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\013\000\002\n\000\003\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetArchivedMessagesInput

@implementation GetArchivedMessagesInput

@dynamic conversationId;
@dynamic botId;

typedef struct GetArchivedMessagesInput__storage_ {
  uint32_t _has_storage_[1];
  NSString *conversationId;
  NSString *botId;
} GetArchivedMessagesInput__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "conversationId",
        .dataTypeSpecific.className = NULL,
        .number = GetArchivedMessagesInput_FieldNumber_ConversationId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetArchivedMessagesInput__storage_, conversationId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "botId",
        .dataTypeSpecific.className = NULL,
        .number = GetArchivedMessagesInput_FieldNumber_BotId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetArchivedMessagesInput__storage_, botId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetArchivedMessagesInput class]
                                     rootClass:[ConversationserviceRoot class]
                                          file:ConversationserviceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetArchivedMessagesInput__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\016\000\002\005\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetArchivedMessagesResponse

@implementation GetArchivedMessagesResponse

@dynamic error;
@dynamic contentArray, contentArray_Count;

typedef struct GetArchivedMessagesResponse__storage_ {
  uint32_t _has_storage_[1];
  int32_t error;
  NSMutableArray *contentArray;
} GetArchivedMessagesResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "error",
        .dataTypeSpecific.className = NULL,
        .number = GetArchivedMessagesResponse_FieldNumber_Error,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetArchivedMessagesResponse__storage_, error),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "contentArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GetArchivedMessagesContent),
        .number = GetArchivedMessagesResponse_FieldNumber_ContentArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetArchivedMessagesResponse__storage_, contentArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetArchivedMessagesResponse class]
                                     rootClass:[ConversationserviceRoot class]
                                          file:ConversationserviceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetArchivedMessagesResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetArchivedMessagesContent

@implementation GetArchivedMessagesContent

@dynamic messageId;
@dynamic contentType;
@dynamic createdOn;
@dynamic createdBy;
@dynamic content;
@dynamic options;

typedef struct GetArchivedMessagesContent__storage_ {
  uint32_t _has_storage_[1];
  NSString *messageId;
  NSString *contentType;
  NSString *createdBy;
  NSData *content;
  NSData *options;
  double createdOn;
} GetArchivedMessagesContent__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "messageId",
        .dataTypeSpecific.className = NULL,
        .number = GetArchivedMessagesContent_FieldNumber_MessageId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetArchivedMessagesContent__storage_, messageId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "contentType",
        .dataTypeSpecific.className = NULL,
        .number = GetArchivedMessagesContent_FieldNumber_ContentType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetArchivedMessagesContent__storage_, contentType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "createdOn",
        .dataTypeSpecific.className = NULL,
        .number = GetArchivedMessagesContent_FieldNumber_CreatedOn,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetArchivedMessagesContent__storage_, createdOn),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "createdBy",
        .dataTypeSpecific.className = NULL,
        .number = GetArchivedMessagesContent_FieldNumber_CreatedBy,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GetArchivedMessagesContent__storage_, createdBy),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = GetArchivedMessagesContent_FieldNumber_Content,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GetArchivedMessagesContent__storage_, content),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "options",
        .dataTypeSpecific.className = NULL,
        .number = GetArchivedMessagesContent_FieldNumber_Options,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(GetArchivedMessagesContent__storage_, options),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetArchivedMessagesContent class]
                                     rootClass:[ConversationserviceRoot class]
                                          file:ConversationserviceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetArchivedMessagesContent__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001\t\000\002\013\000\003\t\000\004\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
